<?php

namespace App\Http\Controllers\Admin;

use App\Http\Controllers\Controller;
use App\Http\Requests\Admin\{{ store_request }};
use App\Http\Requests\Admin\{{ update_request }};
use App\Models\{{ model }};
use Illuminate\Http\Request;
use Illuminate\Support\Str;
use Illuminate\Database\QueryException;
use Illuminate\Database\Eloquent\Relations\Relation;

class {{ controller }} extends Controller
{
    public function index(Request $request)
    {
        // DataTables server-side
        if ($request->ajax()) {
            $base = {{ model }}::query();

            $recordsTotal = (clone $base)->count();

            // global search
            $search = trim((string) data_get($request->all(), 'search.value', ''));
            if ($search !== '') {
                $base->where(function ($q) use ($search) {
                    $q->where('title', 'like', "%{$search}%")
                      ->orWhere('slug', 'like', "%{$search}%");
                });
            }

            $recordsFiltered = (clone $base)->count();

            // order
            $orderColIndex = (int) data_get($request->all(), 'order.0.column', 0);
            $orderDir = data_get($request->all(), 'order.0.dir', 'desc') === 'asc' ? 'asc' : 'desc';

            $orderMap = [
                0 => 'id',
                1 => 'title',
                2 => 'status',
                3 => 'updated_at',
            ];

            $orderCol = $orderMap[$orderColIndex] ?? 'id';
            $base->orderBy($orderCol, $orderDir);

            // paging
            $start = max(0, (int) $request->input('start', 0));
            $length = max(1, (int) $request->input('length', 10));

            $rows = $base->skip($start)->take($length)->get();

            return response()->json([
                'draw' => (int) $request->input('draw', 1),
                'recordsTotal' => $recordsTotal,
                'recordsFiltered' => $recordsFiltered,
                'data' => $rows->map(function ($r) {
                    return [
                        'id' => $r->id,
                        'title' => $r->title,
                        'updated_at' => optional($r->updated_at)->toDateTimeString(),

                        // index.js bunları bekliyor
                        'status_badge' => $this->renderStatusBadge($r->status),
                        'edit_url' => route('{{ admin_prefix }}.{{ route_name_plural }}.edit', $r->id),
                        'trash_url' => route('{{ admin_prefix }}.{{ route_name_plural }}.destroy', $r->id),
                    ];
                })->values(),
            ]);
        }

        return view('admin.pages.{{ module_kebab_plural }}.index');
    }

    public function create()
    {
        return view('admin.pages.{{ module_kebab_plural }}.create', [
            'item' => new {{ model }}(),
        ]);
    }

    public function store({{ store_request }} $request)
    {
        $data = $request->validated();

        $data['slug'] = trim((string)($data['slug'] ?? ''));
        if ($data['slug'] === '') {
            $data['slug'] = Str::slug((string)($data['title'] ?? ''));
        }

        // featured limit (cfg üzerinden)
        $limit = (int) config('admin-module-generator.defaults.featured_limit', {{ featured_limit }});
        if ($limit > 0 && !empty($data['is_featured'])) {
            $count = {{ model }}::where('is_featured', true)->count();
            if ($count >= $limit) {
                return response()->json(['ok'=>false,'message'=>'Öne çıkan limiti dolu.'], 422);
            }
        }

        $item = {{ model }}::create($data);

        return response()->json([
            'ok' => true,
            'redirect' => route('{{ admin_prefix }}.{{ route_name_plural }}.edit', $item->id),
        ]);
    }

    public function edit({{ model }} $item)
    {
        return view('admin.pages.{{ module_kebab_plural }}.edit', compact('item'));
    }

    public function update({{ update_request }} $request, {{ model }} $item)
    {
        $data = $request->validated();

        $limit = (int) config('admin-module-generator.defaults.featured_limit', {{ featured_limit }});
        if ($limit > 0 && !empty($data['is_featured']) && !$item->is_featured) {
            $count = {{ model }}::where('is_featured', true)->count();
            if ($count >= $limit) {
                return response()->json(['ok'=>false,'message'=>'Öne çıkan limiti dolu.'], 422);
            }
        }

        $item->update($data);

        return response()->json(['ok' => true]);
    }

    public function destroy({{ model }} $item)
    {
        $item->delete();
        return response()->json(['ok' => true]);
    }

    // Slug live-check (create/edit.js bunu kullanır)
    public function checkSlug(Request $request)
    {
        $slug = trim((string) $request->query('slug', ''));
        $ignore = $request->query('ignore');

        if ($slug === '') {
            return response()->json(['ok'=>false,'message'=>'Slug boş olamaz.'], 422);
        }

        $q = {{ model }}::query()->where('slug', $slug);
        if ($ignore !== null && is_numeric($ignore)) {
            $q->where('id', '!=', (int) $ignore);
        }

        $exists = $q->exists();

        return response()->json([
            'ok' => !$exists,
            'message' => $exists ? 'Bu slug zaten kullanılıyor.' : null,
        ], $exists ? 409 : 200);
    }

    public function checkFeaturedLimit()
    {
        $limit = (int) config('admin-module-generator.defaults.featured_limit', {{ featured_limit }});
        if ($limit <= 0) return response()->json(['ok'=>true]);

        $count = {{ model }}::where('is_featured', true)->count();
        if ($count >= $limit) {
            return response()->json(['ok'=>false,'message'=>'Öne çıkan limiti dolu.'], 422);
        }

        return response()->json(['ok'=>true]);
    }

    public function trash(Request $request)
    {
        if ($request->ajax()) {
            $rows = {{ model }}::onlyTrashed()->latest('deleted_at')->get();

            return response()->json([
                'ok' => true,
                'data' => $rows->map(function ($r) {
                    [$canForce, $reason] = $this->forceDeleteEligibility($r);

                    return [
                        'id' => $r->id,
                        'title' => $r->title,
                        'deleted_at' => optional($r->deleted_at)->toDateTimeString(),
                        'restore_url' => route('{{ admin_prefix }}.{{ route_name_plural }}.restore', $r->id),
                        'force_url' => route('{{ admin_prefix }}.{{ route_name_plural }}.force', $r->id),
                        'can_force_delete' => $canForce,
                        'force_block_reason' => $reason,
                    ];
                })->values(),
            ]);
        }

        return view('admin.pages.{{ module_kebab_plural }}.trash');
    }

    public function restore(int $id)
    {
        {{ model }}::onlyTrashed()->findOrFail($id)->restore();
        return response()->json(['ok'=>true]);
    }

    public function forceDelete(int $id)
    {
        $item = {{ model }}::onlyTrashed()->findOrFail($id);

        try {
            $item->forceDelete();
        } catch (\Throwable $e) {
            return response()->json(['ok'=>false,'message'=>$this->friendlyDeleteError($e)], 409);
        }

        return response()->json(['ok'=>true]);
    }

    public function bulkRestore(Request $request)
    {
        $ids = (array) $request->input('ids', []);
        {{ model }}::onlyTrashed()->whereIn('id', $ids)->restore();
        return response()->json(['ok'=>true]);
    }

    public function bulkForceDelete(Request $request)
    {
        $ids = (array) $request->input('ids', []);
        $items = {{ model }}::onlyTrashed()->whereIn('id', $ids)->get();

        $failed = [];
        $deleted = 0;

        foreach ($items as $item) {
            try {
                $item->forceDelete();
                $deleted++;
            } catch (\Throwable $e) {
                $failed[$item->id] = $this->friendlyDeleteError($e);
            }
        }

        return response()->json([
            'ok' => count($failed) === 0,
            'count' => $deleted,
            'failed' => $failed,
        ]);
    }

    private function friendlyDeleteError(\Throwable $e): string
    {
        if ($e instanceof QueryException) {
            return 'Bağlı kayıtlar nedeniyle silinemedi.';
        }
        return 'Kalıcı silme başarısız.';
    }

    private function forceDeleteEligibility({{ model }} $item): array
    {
        if (!method_exists($item, 'forceDeleteBlockers')) {
            return [true, null];
        }

        foreach ((array)$item->forceDeleteBlockers() as $b) {
            $rel = $b['relation'] ?? null;
            $label = $b['label'] ?? 'Bağlı kayıt var';

            if (!$rel || !method_exists($item, $rel)) {
                continue;
            }

            try {
                $relationObj = $item->{$rel}();
                if (!$relationObj instanceof Relation) continue;

                if ($relationObj->count() > 0) {
                    return [false, $label];
                }
            } catch (\Throwable $e) {
                return [false, 'Bağlı kayıt kontrolü yapılamadı'];
            }
        }

        return [true, null];
    }

    private function renderStatusBadge(?string $status): string
    {
        $s = $status ?: 'draft';

        $cls = $s === 'published'
            ? 'kt-badge kt-badge-sm kt-badge-success'
            : 'kt-badge kt-badge-sm kt-badge-light';

        return '<span class="'.$cls.'">'.e($s).'</span>';
    }
}
